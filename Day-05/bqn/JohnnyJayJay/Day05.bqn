# Line descriptor = list of starting and ending point, e.g. âŸ¨3â€¿9, 6â€¿9âŸ©
Direction â† Ã—-ËœÂ´ # For a line descriptor, return the directional vector
Steps â† 1+(âŒˆÂ´|âˆ˜-ËœÂ´) # For a line descriptor, return how steps are required to get from the former to the latter ("0th" step included)
Points â† {(âŠ‘ğ•©)âŠ¸+Â¨ (Direction ğ•©)âŠ¸Ã—Â¨ â†•Steps ğ•©} # For a line descriptor, return all the points the line traverses
Straight â† âˆ¨Â´=Â´ # Return 1 if a line is straight, 0 if it's diagonal
# Collect all points all lines traverse, group by equality, filter out groups of only 1 point, count remaining
PartTwo â† â‰  (2âŠ¸â‰¤âˆ˜â‰ Â¨âŠ¸/)âˆ˜(âŠâŠ¸âŠ”)âˆ˜(âˆ¾Â´)âˆ˜(PointsÂ¨)
PartOne â† PartTwoâˆ˜(StraightÂ¨/âŠ¢)

Parse â† â€¢BQNÂ¨('âŸ¨'âŠ¸âˆ¾âˆ¾âŸœ'âŸ©')Â¨âˆ˜((âŠ‘âŠâŸœ' ') (â†‘â‹ˆ(+âŸœ4âŠ¸â†“))âŠ¢) # "x1,y1 -> x2,y2" => âŸ¨x1â€¿y1, x2â€¿y2âŸ©

input â† ParseÂ¨ â€¢FLines âŠ‘ â€¢args

â€¢Out PartOne input
â€¢Out PartTwo input
